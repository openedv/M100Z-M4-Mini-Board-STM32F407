/* USER CODE BEGIN Header */

/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "dcmi.h"
#include "dma.h"
#include "tim.h"
#include "usart.h"
#include "gpio.h"
#include "fsmc.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "../../BSP/LED/led.h"
#include "../../BSP/KEY/key.h"
#include "../../BSP/LCD/lcd.h"
#include "../../BSP/OV2640/ov2640.h"
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */
extern DMA_HandleTypeDef hdma_dcmi;
extern void (*dcmi_rx_callback)(void);
/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */
/**
 * @brief   Displays information about the experiment
 * @param   None
 * @retval  None
 */
void stm32f407vg_show_mesg(void)
{
	/* The serial port outputs the experimental information */
	printf("\n");
	printf("********************************\r\n");
	printf("STM32F407\r\n");
	printf("CAMERA Test\r\n");
	printf("ATOM@ALIENTEK\r\n");
	printf("********************************\r\n");
	printf("\r\n");
}

/* OV2640ËæìÂá∫Êï∞ÊçÆÊ†ºÂºè
 * 0: RGB565Ê†ºÂºè
 * 1: JPEGÊ†ºÂºè
 */
static uint8_t g_ov_mode;

/* JPEGÁõ∏ÂÖ≥Êï∞ÊçÆÁºìÂ≠òÂÆö‰πâ */
#define JPEG_BUF_SIZE   (29 * 1024)                                             /* JPEGÊï∞ÊçÆÁºìÂ≠òÂ§ßÂ∞è */
#define JPEG_LINE_SIZE  (1 * 1024)                                              /* JPEGÊï∞ÊçÆDMAÂèåÁºìÂ≠òÂ§ßÔø?? */
static uint32_t g_jpeg_data_buf[JPEG_BUF_SIZE] __attribute__((aligned(4)));     /* JPEGÊï∞ÊçÆÁºìÂ≠òÔø?? */
static uint32_t g_dcmi_line_buf[2][JPEG_LINE_SIZE] __attribute__((aligned(4))); /* JPEGÊï∞ÊçÆDMAÂèåÁºìÂ≠òÂå∫ */
volatile uint32_t g_jpeg_data_len = 0;                                          /* JPEGÊï∞ÊçÆÁºìÂ≠òÂå∫‰∏≠ÊúâÊïàÊï∞ÊçÆÁöÑÈïøÔø?? */

/* JPEGÊï∞ÊçÆÈááÈõÜÂÆåÊàêÊ†áÂøó
 * 0: ÈááÈõÜÊú™ÂÆåÔø??
 * 1: ÈááÈõÜÂÆåÊàêÔºå‰ΩÜËøòÊú™Â§ÑÁêÜ
 * 2: Â§ÑÁêÜÂÆåÊàêÔºåÂèØ‰ª•ÂºÄÂßãÊé•Êî∂‰∏ãÔø??Ôø??
 */
volatile uint8_t g_jpeg_data_ok = 0;

/* JPEGÂõæÁâáÔø??13ÁßçÂ∞∫ÂØ∏ÂêçÔø?? */
static const char *jpeg_size_tbl[13] = {"QQVGA", "QCIF", "QVGA", "WGVGA", "CIF", "VGA", "SVGA", "XGA", "WXGA", "SVGA", "WXGA+", "SXGA", "UXGA"};

/* JPEGÂõæÁâáÔø??13ÁßçÂ∞∫ÂØ∏ÂèÇÔø?? */
static const uint16_t jpeg_img_size_tbl[][2] = {
    { 160,  120},   /* QQVGA */
    { 176,  144},   /* QCIF */
    { 320,  240},   /* QVGA */
    { 400,  240},   /* WGVGA */
    { 352,  288},   /* CIF */
    { 640,  480},   /* VGA */
    { 800,  600},   /* SVGA */
    {1024,  768},   /* XGA */
    {1280,  800},   /* WXGA */
    {1280,  960},   /* XVGA */
    {1440,  900},   /* WXGA+ */
    {1280, 1024},   /* SXGA */
    {1600, 1200},   /* UXGA */
};

/**
 * @bref        Â§ÑÁêÜJPEGÊï∞ÊçÆ
 * @note        Âú®DCMIÊçïËé∑‰∏≠Êñ≠‰∏≠Ë∞ÉÔø??
 * @param       Ôø??
 * @retval      Ôø??
 */
void jpeg_data_process(void)
{
    uint16_t rlen;
    uint32_t *pbuf;
    uint16_t i;

    if (g_ov_mode != 0)                                                         /* JPEGÊ®°Âºè */
    {
        if (g_jpeg_data_ok == 0)                                                /* ËøòÊú™ÈááÈõÜJPEGÊï∞ÊçÆ */
        {
            __HAL_DMA_DISABLE(&hdma_dcmi);                              /* Á¶ÅÁî®DCMI‰º†Âá∫‰ΩøÁî®ÁöÑDMAÊï∞ÊçÆÔø?? */
            while (DMA2_Stream1->CR & 0x01);                                    /* Á≠âÂæÖDMAÂèØÈÖçÔø?? */

            rlen = JPEG_LINE_SIZE - __HAL_DMA_GET_COUNTER(&hdma_dcmi);  /* ËÆ°ÁÆóÂâ©‰ΩôÈïøÂ∫¶ */
            pbuf = g_jpeg_data_buf + g_jpeg_data_len;                           /* ÂÅèÁßªÂà∞JPEGÊï∞ÊçÆÁºìÂ≠ò‰∏≠ÊúâÊïàÊï∞ÊçÆÁöÑÊú´Â∞æÔºåÁªßÁª≠Ê∑ªÂä†Êñ∞ÁöÑJPEGÊï∞ÊçÆ */

            if (DMA2_Stream1->CR & (1 << 19))                                   /* DMAÊ≠£Âú®Â§ÑÁêÜÂ≠òÂÇ®Ôø??1ÔºåÂõ†Ê≠§‰ªéÂ≠òÂÇ®Ôø??1‰∏≠ËØªÂèñÊï∞Ôø?? */
            {
                for (i=0; i<rlen; i++)
                {
                    pbuf[i] = g_dcmi_line_buf[1][i];
                }
            }
            else                                                                /* DMAÊ≠£Âú®Â§ÑÁêÜÂ≠òÂÇ®Ôø??0ÔºåÂõ†Ê≠§‰ªéÂ≠òÂÇ®Ôø??0‰∏≠ËØªÂèñÊï∞Ôø?? */
            {
                for (i=0; i<rlen; i++)
                {
                    pbuf[i] = g_dcmi_line_buf[0][i];
                }
            }
            g_jpeg_data_len += rlen;                                            /* Êõ¥Êñ∞JPEGÊï∞ÊçÆÁºìÂ≠òÂå∫‰∏≠ÊúâÊïàÊï∞ÊçÆÁöÑÈïøÔø?? */
            g_jpeg_data_ok = 1;                                                 /* Ê†áËÆ∞Â∑≤ÈááÈõÜJPEGÊï∞ÊçÆ */
        }
        else if (g_jpeg_data_ok == 2)                                           /* ‰∏ä‰∏ÄÊ¨°ÈááÈõÜÁöÑJPEGÊï∞ÊçÆÂ∑≤Â§ÑÁêÜÂÆåÔø?? */
        {
            __HAL_DMA_SET_COUNTER(&hdma_dcmi, JPEG_LINE_SIZE);          /* ËÆæÁΩÆDMA‰º†ËæìÁöÑÊï∞ÊçÆÈ°πÊï∞ÁõÆ */
            __HAL_DMA_ENABLE(&hdma_dcmi);                               /* ‰ΩøËÉΩDMAÊï∞ÊçÆÔø?? */
            g_jpeg_data_len = 0;                                                /* Ôø??ÂßãÊñ∞ÁöÑJPEGÊï∞ÊçÆÊé•Êî∂ */
            g_jpeg_data_ok = 0;                                                 /* Ê†áËÆ∞ËøòÊú™ÈááÈõÜJPEGÊï∞ÊçÆ */
        }
    }
    else                                                                /* RGB565Ê®°Âºè */
    {
        lcd_set_cursor(0, 0);                                           /* ËÆæÁΩÆÂÖâÊ†á‰ΩçÁΩÆ */
        lcd_write_ram_prepare();                                        /* ÂáÜÂ§áÂÜôGRAM */
    }
}

/**
 * @bref        JPEGÊï∞ÊçÆÂ§ÑÁêÜÂõûË∞É
 * @note        ‰ªÖ‰ΩøÁî®ÂèåÁºìÂÜ≤Âå∫Ê®°ÂºèÊó∂‰ΩøÁî®ÔºåÂú®DMA‰º†ËæìÂÆåÊàê‰∏≠Êñ≠‰∏≠Ë∞ÉÔø??
 * @param       Ôø??
 * @retval      Ôø??
 */
static void jpeg_dcmi_rx_callback(void)
{
    uint16_t i;
    volatile uint32_t *pbuf;

    pbuf = g_jpeg_data_buf + g_jpeg_data_len;           /* ÂÅèÁßªÂà∞ÊúâÊïàÊï∞ÊçÆÊú´Ôø?? */
    if (DMA2_Stream1->CR & (1 << 19))                   /* DMAÊ≠£Âú®Â§ÑÁêÜÂ≠òÂÇ®Ôø??1ÔºåËøôÈáåÂ§ÑÁêÜÂ≠òÂÇ®Âô®0ÁöÑÊï∞Ôø?? */
    {
        for (i=0; i<JPEG_LINE_SIZE; i++)                /* Â§çÂà∂DMAÂ≠òÂÇ®Ôø??0ÁöÑÊï∞ÊçÆËá≥JPEGÊï∞ÊçÆÁºìÂ≠òÔø?? */
        {
            pbuf[i] = g_dcmi_line_buf[0][i];
        }
        g_jpeg_data_len += JPEG_LINE_SIZE;              /* Êõ¥Êñ∞JPEGÊï∞ÊçÆÁºìÂ≠òÂå∫‰∏≠ÊúâÊïàÊï∞ÊçÆÁöÑÈïøÔø?? */
    }
    else                                                /* DMAÊ≠£Âú®Â§ÑÁêÜÂ≠òÂÇ®Ôø??0ÔºåËøôÈáåÂ§ÑÁêÜÂ≠òÂÇ®Âô®1ÁöÑÊï∞Ôø?? */
    {
        for (i=0; i<JPEG_LINE_SIZE; i++)                /* Â§çÂà∂DMAÂ≠òÂÇ®Ôø??1ÁöÑÊï∞ÊçÆËá≥JPEGÊï∞ÊçÆÁºìÂ≠òÔø?? */
        {
            pbuf[i] = g_dcmi_line_buf[1][i];
        }
        g_jpeg_data_len += JPEG_LINE_SIZE;              /* Êõ¥Êñ∞JPEGÊï∞ÊçÆÁºìÂ≠òÂå∫‰∏≠ÊúâÊïàÊï∞ÊçÆÁöÑÈïøÔø?? */
    }
}

/**
 * @bref        JPEGÊ®°ÂºèÊµãËØï
 * @note        Ëé∑ÂèñOV2640ËæìÂá∫ÁöÑJPEGÊï∞ÊçÆÔºåÂπ∂ÈÄöËøáUSART2ÂèëÔøΩ?ÔøΩËá≥‰∏ä‰ΩçÔø??
 * @param       Ôø??
 * @retval      Ôø??
 */
static void jpeg_test(void)
{
    uint8_t msgbuf[15];                                                             /* ÊèêÁ§∫‰ø°ÊÅØÁºìÂÜ≤Ôø?? */
    uint8_t size = 2;                                                               /* ÈªòËÆ§‰ΩøÁî®QVGAÔø??320*240Ôø?? */
    uint8_t contrast = 2;                                                           /* ÈªòËÆ§‰ΩøÁî®Ê≠£Â∏∏ÂØπÊØîÔø?? */
    uint8_t *p;
    uint32_t jpeglen;
    uint8_t headok;
    uint32_t i;
    uint32_t jpegstart;
    uint8_t key;

    lcd_clear(WHITE);
    lcd_show_string(30, 50, 200, 16, 16, "STM32", RED);
    lcd_show_string(30, 70, 200, 16, 16, "OV2640 JPEG Mode", RED);
    lcd_show_string(30, 100, 200, 16, 16, "KEY0:Contrast", RED);                    /* ÂØπÊØîÔø?? */
    lcd_show_string(30, 120, 200, 16, 16, "WKUP:Size", RED);                        /* ÂàÜËæ®ÁéáËÆæÔø?? */
    sprintf((char *)msgbuf, "JPEG Size:%s", jpeg_size_tbl[size]);
    lcd_show_string(30, 140, 200, 16, 16, (char*)msgbuf, RED);                      /* ÂΩìÂâçJPEGÂàÜËæ®Ôø?? */

    ov2640_jpeg_mode();                                                             /* ÈÖçÁΩÆOV2640‰∏∫JPEGÊ®°Âºè */
    MX_DCMI_Init();                                                                    /* ÂàùÂßãÂåñDCMI */
    dcmi_rx_callback = jpeg_dcmi_rx_callback;                                       /* DMA‰º†ËæìÂÆåÊàêÂõûË∞É */
    dcmi_dma_init((uint32_t)g_dcmi_line_buf[0],                                     /* ÈÖçÁΩÆDCMI DMA */
                     (uint32_t)g_dcmi_line_buf[1],
                     JPEG_LINE_SIZE,
                     DMA_MDATAALIGN_WORD,
                     DMA_MINC_ENABLE);
    ov2640_outsize_set(jpeg_img_size_tbl[size][0], jpeg_img_size_tbl[size][1]);     /* ËÆæÁΩÆÂõæÂÉèËæìÂá∫Â§ßÂ∞è */
    dcmi_start();                                                                   /* ÂêØÂä®DCMI‰º†Ëæì */

    while (1)
    {
        if (g_jpeg_data_ok == 1)                                                    /* JPEGÊï∞ÊçÆÈááÈõÜÂÆåÊàê */
        {
            p = (uint8_t *)g_jpeg_data_buf;
            printf("g_jpeg_data_len:%d\r\n", g_jpeg_data_len << 2);                 /* ÊâìÂç∞JPEGÊï∞ÊçÆÈïøÂ∫¶ */
            lcd_show_string(30, 170, 210, 16, 16, "Sending JPEG data...", RED);     /* ÊèêÁ§∫Ê≠£Âú®‰º†ËæìJPEGÊï∞ÊçÆ */
            jpeglen = 0;
            headok = 0;

            for (i=0; i<((g_jpeg_data_len << 2) - 1); i++)                          /* ÈÅçÂéÜJPEGÊï∞ÊçÆÔºåÊü•ÊâæJPEGÊï∞ÊçÆÂ§¥Ôºà0xFFÔø??0xD8ÔºâÂíåJPEGÊï∞ÊçÆÂ∞æÔºà0xFFÔø??0xD9Ôø?? */
            {
                if ((p[i] == 0xFF) && (p[i + 1] == 0xD8))                           /* ÊâæÂà∞JPEGÊï∞ÊçÆÔø?? */
                {
                    jpegstart = i;
                    headok = 1;
                }

                if (headok != 0)                                                    /* ÊâæÂà∞JPEGÊï∞ÊçÆÂ§¥ÂêéÔºåÂú®Ôø??ÂßãÊâæJPEGÊï∞ÊçÆÔø?? */
                {
                    if ((p[i] == 0xFF) && (p[i + 1] == 0xD9))                       /* ÊâæÂà∞JPEGÊï∞ÊçÆÔø?? */
                    {
                        jpeglen = i - jpegstart + 2;
                        break;
                    }
                }
            }

            if (jpeglen != 0)                                                       /* JPEGÊï∞ÊçÆÊ≠£Â∏∏ */
            {
                p += jpegstart;                                                     /* ÂÅèÁßªÂà∞JPEGÊï∞ÊçÆÂ§¥ÁöÑ‰ΩçÁΩÆ */
                for (i=0; i<jpeglen; i++)                                           /* ÂèëÔøΩ?ÔøΩÊï¥‰∏™ÊúâÊïàÁöÑJPEGÊï∞ÊçÆÔºàJPEGÊï∞ÊçÆÂ§¥ÊâìÂà∞JPEGÊï∞ÊçÆÂ∞æÔºâ */
                {
                    USART2->DR = p[i];
                    while ((USART2->SR & 0X40) == 0);
                    key = key_scan(0);                                              /* ‰ªªÊÑèÊåâÈîÆÂèØÊâìÊñ≠Êï∞ÊçÆÂèëÔø?? */
                    if (key != 0)
                    {
                        break;
                    }
                }
            }

            if (key != 0)
            {
                lcd_show_string(30, 170, 210, 16, 16, "Quit Sending data   ", RED); /* ÊèêÁ§∫Ôø??Âá∫JPEGÊï∞ÊçÆ‰º†Ëæì */
                switch (key)
                {
                    case KEY0_PRES: /* ËÆæÁΩÆÂØπÊØîÔø?? */
                    {
                        contrast++;
                        if (contrast > 4)
                        {
                            contrast = 0;
                        }
                        ov2640_contrast(contrast);
                        sprintf((char *)msgbuf, "Contrast:%d", (int8_t)contrast - 2);
                        break;
                    }
                    case WKUP_PRES: /* ËÆæÁΩÆÂàÜËæ®Ôø?? */
                    {
                        size++;
                        if (size > 12)
                        {
                            size = 0;
                        }
                        ov2640_outsize_set(jpeg_img_size_tbl[size][0], jpeg_img_size_tbl[size][1]);
                        sprintf((char *)msgbuf, "JPEG Size:%s", jpeg_size_tbl[size]);
                    }
                    default:
                    {
                        break;
                    }
                }
                lcd_fill(30, 140, 239, 190 + 16, WHITE);
                lcd_show_string(30, 140, 210, 16, 16, (char*)msgbuf, RED);          /* ÊòæÁ§∫ÊèêÁ§∫ÂÜÖÂÆπ */
                HAL_Delay(800);
            }
            else
            {
                lcd_show_string(30, 170, 210, 16, 16, "Send data complete!!", RED); /* ÊèêÁ§∫JPEGÊï∞ÊçÆ‰º†ËæìÁªìÊùü */
            }

            g_jpeg_data_ok = 2;                                                     /* Ê†áËÆ∞JPEGÊï∞ÊçÆÂ§ÑÁêÜÂÆåÊàêÔºåÂèØ‰ª•ÂºÄÂßãÊé•Êî∂‰∏ãÔø??Ôø?? */
        }
    }
}

/**
 * @bref        RGB565Ê®°ÂºèÊµãËØï
 * @note        Ëé∑ÂèñOV2640ËæìÂá∫ÁöÑRGBÊï∞ÊçÆÔºåÂπ∂Áõ¥Êé•Âú®LCD‰∏äÊòæÔø??
 * @param       Ôø??
 * @retval      Ôø??
 */
static void rgb565_test(void)
{
    uint8_t key;
    uint8_t contrast = 2;   /* ÈªòËÆ§‰ΩøÁî®Ê≠£Â∏∏ÂØπÊØîÔø?? */
    uint8_t scale = 1;      /* ÈªòËÆ§ÂÖ®Â±èÁº©Êîæ */
    uint8_t msgbuf[15];     /* ÊèêÁ§∫‰ø°ÊÅØÁºìÂÜ≤Ôø?? */

    lcd_clear(WHITE);
    lcd_show_string(30, 50, 200, 16, 16, "STM32", RED);
    lcd_show_string(30, 70, 200, 16, 16, "OV2640 RGB565 Mode", RED);
    lcd_show_string(30, 100, 200, 16, 16, "KEY0:Contrast", RED);            /* ÂØπÊØîÂ∫¶ËÆæÔø?? */
    lcd_show_string(30, 160, 200, 16, 16, "WKUP:FullSize/Scale", RED);      /* Áº©ÊîæËÆæÁΩÆ */

    ov2640_rgb565_mode();                                                   /* ÈÖçÁΩÆOV2640‰∏∫RGB565Ê®°Âºè */
    MX_DCMI_Init();                                                            /* ÂàùÂßãÂåñDCMI */
    dcmi_dma_init((uint32_t)&(LCD->LCD_RAM),                                /* ÈÖçÁΩÆDCMI DMA */
                     0,
                     1,
                     DMA_MDATAALIGN_HALFWORD,
                     DMA_MINC_DISABLE);
    ov2640_outsize_set(lcddev.width, lcddev.height);                        /* ÂÖ®Â±èÁº©Êîæ */
    dcmi_start();                                                           /* ÂêØÂä®DCMI‰º†Ëæì */

    while (1)
    {
        key = key_scan(0);

        if (key != 0)
        {
            dcmi_stop();                                                    /* ÂÅúÊ≠¢DCMI‰º†Ëæì */
            switch (key)
            {
                case KEY0_PRES:                                             /* ËÆæÁΩÆÂØπÊØîÔø?? */
                {
                    contrast++;
                    if (contrast > 4)
                    {
                        contrast = 0;
                    }
                    ov2640_contrast(contrast);
                    sprintf((char *)msgbuf, "Contrast:%d", (int8_t)contrast - 2);
                    break;
                }
                case WKUP_PRES:                                             /* ËÆæÁΩÆÁº©Êîæ */
                {
                    scale = !scale;
                    if (scale == 0)                                         /* ‰∏çÁº©Ôø?? */
                    {
                        ov2640_image_win_set((1600 - lcddev.width) >> 1,
                                             (1200 - lcddev.height) >> 1,
                                             lcddev.width,
                                             lcddev.height);
                        ov2640_outsize_set(lcddev.width, lcddev.height);
                        sprintf((char *)msgbuf, "Full Size 1:1");
                    }
                    else                                                    /* ÂÖ®Â±èÁº©Êîæ */
                    {
                        ov2640_image_win_set(0, 0, 1600, 1200);
                        ov2640_outsize_set(lcddev.width, lcddev.height);
                        sprintf((char *)msgbuf, "Scale");
                    }
                }
                default:
                {
                    break;
                }
            }
            lcd_show_string(30, 50, 210, 16, 16, (char*)msgbuf, RED);       /* ÊòæÁ§∫ÊèêÁ§∫ÂÜÖÂÆπ */
            HAL_Delay(800);
            dcmi_start();                                                   /* ÈáçÊñ∞ÂêØÂä®DCMI‰º†Ëæì */
        }
        HAL_Delay(10);
    }
}
/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/

/* USER CODE BEGIN PV */

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
/* USER CODE BEGIN PFP */

/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
  /* USER CODE BEGIN 1 */
  uint8_t t = 0;
  uint8_t key;
  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();

  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();

  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_DMA_Init();
  MX_USART1_UART_Init();
  MX_FSMC_Init();
  MX_TIM6_Init();
  MX_USART2_UART_Init();
  MX_DCMI_Init();
  /* USER CODE BEGIN 2 */
  lcd_init();                                         /* Initialize LCD */
  stm32f407vg_show_mesg();
  lcd_show_string(30, 50, 200, 16, 16, "STM32", RED);
  lcd_show_string(30, 70, 200, 16, 16, "OV2640 TEST", RED);
  lcd_show_string(30, 90, 200, 16, 16, "ATOM@ALIENTEK", RED);

  while (ov2640_init() != 0)                                      /* ÂàùÂßãÂåñOV2640 */
  {
      lcd_show_string(30, 130, 200, 16, 16, "OV2640 ERROR ", RED);
      HAL_Delay(200);
      lcd_show_string(30, 130, 200, 16, 16, "Please Check! ", RED);
      HAL_Delay(500);
      LED0_TOGGLE();
  }
  lcd_show_string(30, 130, 200, 16, 16, "OV2640 OK     ", RED);
  ov2640_flash_intctrl();                                         /* Internal control flash */
  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
	  t++;
	  key = key_scan(0);

	  if (key == KEY0_PRES)                                       /* RGB565Ê®°Âºè */
	  {
	      g_ov_mode = 0;
	      break;
	  }
	  else if (key == WKUP_PRES)                                  /* JPEGÊ®°Âºè */
	  {
	      g_ov_mode = 1;
	      break;
	  }

	  if (t == 100)
	  {
	      lcd_show_string(30, 150, 230, 16, 16, "KEY0:RGB565  WK_UP:JPEG", RED);
	  }
	  else if (t == 200)
	  {
	      t = 0;
	      lcd_fill(30, 150, 230, 150 + 16, WHITE);
	      LED0_TOGGLE();
	  }

	  HAL_Delay(5);

  if (g_ov_mode == 0)
  {
      rgb565_test();                                              /* RGB565Ê®°ÂºèÊµãËØï */
  }
  else
  {
	  jpeg_test();                                                /* JPEGÊ®°ÂºèÊµãËØï */
  }
    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
  }
  /* USER CODE END 3 */
}

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  /** Configure the main internal regulator output voltage
  */
  __HAL_RCC_PWR_CLK_ENABLE();
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL.PLLM = 8;
  RCC_OscInitStruct.PLL.PLLN = 168;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
  RCC_OscInitStruct.PLL.PLLQ = 4;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
  {
    Error_Handler();
  }
}

/* USER CODE BEGIN 4 */

/* USER CODE END 4 */

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
  {
  }
  /* USER CODE END Error_Handler_Debug */
}

#ifdef  USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */
